## クラス
- 自分で作ることができるデータ型
- 配列は同じデータ型の値のみ、まとめる
- 例えば試験の点数を管理するアプリならUser型といった`名前`、`点数`をまとめられる独自のデータ型を作れる
## Userクラスを定義してみる`class データ型の名前 {}`
- プログラムの前で定義
- クラスで作成する独自のデータ型の名前は、大文字から始める`User`
- 保持したい値を変数のように宣言する`String name;` `int score;`
- クラス内で定義する変数のことを`field`と呼ぶ
- `User`型の値、インスタンスの作成`new User()`、これで1つの値になるので変数に代入可能`user1 = new User`
- 変数の宣言にはデータ型の指定`User user1 = new User();`
```java
class User {
  String name; // field
  int score; // field
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User();
    User user2 = new User();
  }
}
```
## フィールドの値の設定`インスタンス名.フィールド名 = ○○`
- インスタンス名`user1`と`.`の後ろに設定したいフィールド名を書き値を代入する`user1.name = "Taro";`
```java
class User {
  String name; // field
  int score; // field
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User();
    user1.name = "Taro";
    user1.score = 70;
    User user2 = new User();
    user2.name = "Jiro";
    user2.score = 80;
  }
}
```
## コンストラクタ
- インスタンス作成時に渡された値を受け取るようにできる、クラス内で定義するメソッド
1. インスタンス作成時`new`にあらかじめ値を渡す`User user1 = new User("Taro", 70);`
2. クラス内でメソッドの定義、メソッド名はクラス名と同じ`User () {}`
3. 実引数を受け取るための仮引数の設定`String nameFromNew`、`int scoreFromNew`
4. インスタンスごとに違う変数に代入していくので特殊な書き方が必要`User`クラスから作られるインスタンスは`User`クラス内では`this`と表現する
    - `user1` `user2`はインスタンス名だが、インスタンスを作成する前`User user1;`時点では変数名なので「インスタンスごと`に`違う変数に代入していく」
```java
class User {
  String name;
  int score;

  // constructor
  User (String nameFromNew, int scoreFromNew) {
    this.name = nameFromNew;
    this.score = scoreFromNew;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    // user1.name = "Taro";
    // user1.score = 70;
    User user2 = new User("Jiro", 80);
    // user2.name = "Jiro";
    // user2.score = 80;
    
    System.out.println(user1.name);
    System.out.println(user1.score);
    System.out.println(user2.name);
    System.out.println(user2.score);
  }
}
```
- 仮引数は慣れてくるとフィールド名を使い書くことも多い
```java
User (String name, int score) {
    this.name = name;
    this.score = score;
}
```
## クラスメソッドの定義
- クラス内でインスタンスの情報を1行で表示するメソッド`getUserString`を定義する
```java
class User {
  String name;
  int score;

  // constructor
  User (String nameFromNew, int scoreFromNew) {
    this.name = nameFromNew;
    this.score = scoreFromNew;
  }

  getUserString() {
    return this.name + ", " + score;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);
    
    System.out.println(user1.getUserString());
    System.out.println(user2.getUserString());
  }
}
```
### this
- 仮引数かフィールドか分からなくなる`this`は省略できない
```java
User (String nameFromNew, int scoreFromNew) {
    this.name = nameFromNew;
    this.score = scoreFromNew;
  }
```
- 仮引数がない`this`は省略可能
```java
getUserString() {
    return this.name + ", " + score;
  }
```
## メソッドを介して値の変更
- `user1`の`score`が間違っていた場合、直接`score`フィールドを書き換え`user1.score = 90;`のように訂正することもできるが`900`と誤入力してもそのまま表示されてしまう
- メソッドを使った値の更新、変な値が渡されたら修正されないようにする
- 返り値を返さず、内部の処理を行うだけのメソッド`setScore`の定義
1. 返り値はないので`void`
2. 0以上100以下の範囲の設定`if (score < 0 || score > 100)`
3. 範囲外の場合`System.out.println("Invalid score!");`無効メッセージ表示→メソッドの終了`return;`
4. 範囲内の場合、インスタンスの値変更`this.score = score;`
```java
class User {
  String name;
  int score;

  User(String name, int score) {
    this.name = name;
    this.score = score;
  }

  String getUserString() {
    return this.name + ", " + this.score;
  }

  void setScore(int score) { // 1.
    if (score < 0 || score > 100) { // 2.
      System.out.println("Invalid score!"); // 3.
      return;
    }
    this.score = score; // 4.
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    // user1.score = 900;
    user1.setScore(900);

    System.out.println(user1.getUserString());
    System.out.println(user2.getUserString());
  }
}
```
出力結果は
```
Invalid score!
Taro, 70
Jiro, 80
```
## アクセス修飾子
### カプセル化
- `private`というアクセス修飾子を付ければ`User`クラス外からは`score`フィールドへのアクセス制限
- フィールドの書き換え無効`user1.score = 900;`
- 値の代入だけでなく取得も制限される`System.out.println(user1.score);`
- `private`にしたフィールドを取得する場合、その処理についてメソッドの定義が必要`getScore`
- フィールドを`private`にしておいて、安全にアクセスするためのメソッドを別途に用意するテクニックはよく使われる
    - その際フィールドに値をセットするメソッドを`セッター`、取得するメソッドを`ゲッター`と呼ぶ
```java
class User {
  String name;
  private int score; // Userクラス外からアクセス不可

  User(String name, int score) {
    this.name = name;
    this.score = score;
  }

  String getUserString() {
    return this.name + ", " + this.score;
  }

  int getScore() {
    return this.score;
  }

  // setter
  void setScore(int score) {
    if (score < 0 || score > 100) {
      System.out.println("Invalid score!");
      return;
    }
    this.score = score;
  }

  // getter
  int getScore() {
    return this.score;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    user1.score = 900; // 無効！！
    // user1.setScore(900);
    System.out.println(user1.score); // 無効！！
    System.out.println(user1.getScore);

    System.out.println(user1.getUserString());
    System.out.println(user2.getUserString());
  }
}
```
## メソッドへのアクセス制限
- `score`によって`Pass`か`Fail`を出力する`getResult`メソッドを`User`クラスで定義
- クラス外からのメソッドへのアクセスを制限したい場合`private`をメソッドデータ型の前につける`private String getResult() {}`
- 下記では`getUserString`メソッドによりインスタンスの`name` `score` `getResult`を1行で出力
```java
class User {
  String name;
  private int score;

  User(String name, int score) {
    this.name = name;
    this.score = score;
  }

  String getUserString() {
    return this.name + ", " + this.score + ", " + this.getResult(); // こちらで1行で出力
  }

  // setter
  void setScore(int score) {
    if (score < 0 || score > 100) {
      System.out.println("Invalid score!");
      return;
    }
    this.score = score;
  }

  // getter
  int getScore() {
    return this.score;
  }

  private String getResult() {
    if (this.score >= 80) {
      return "Pass";
    } else {
      return "Fail";
    }
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    System.out.println(user1.getUserString());
    System.out.println(user2.getUserString());
    System.out.println(user1.getResult()); // privateによりアクセス制限 エラー
    System.out.println(user2.getResult()); // privateによりアクセス制限 エラー
  }
}
```
## クラス変数
- `User`クラスのインスタンスをいくつ作ったか確認したい
- `User`クラス外で`int count = 0;`→インスタンス作成ごとに`count++;`でも処理可能だがクラスに関わることなのでクラス内で定義したい
1. カウントするための変数`int count = 0;`を`user`クラスのフィールドに書き加える
2. このままではそれぞれのインスタンスが独自の`count`変数を保持するのでクラス全体のインスタンスのカウントをしたい場合には`static`を付け`static int count = 0;`とする
3. コンストラクタでインスタンスが作成された際の処理を記述`count++;`or`User.count++;`
4. `User`クラスの外で使うことも可能だがその際はクラス名が必要
```java
class User {
  String name; // インスタンス変数
  int score; // インスタンス変数
  static int count = 0; // 1. & 2. クラス変数

  User(String name, int score) {
    this.name = name;
    this.score = score;
    count++; // 3.
  }
}

public class MyApp {
  public static void main(String[] args) {
    // int count = 0;
    User user1 = new User("Taro", 70);
    // count++;
    User user2 = new User("Jiro", 80);
    // count++;

    // System.out.println(count);
    System.out.println(User.count); // 4.
  }
}
```
### クラス変数とインスタンス変数
- `String name;` `int score;`が個々のインスタンスに関する値を保持する変数なのでインスタンス変数
- `static int count = 0;`がクラス全体に関する値を保持するのでクラス変数
## クラスメソッド
```java
class User {
  String name;
  int score;
  static int count = 0;

  User(String name, int score) {
    this.name = name;
    this.score = score;
    User.count++;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    System.out.println(User.count);
  }
}
```
1. 今は`count`変数はクラス外で操作できる`User.count++;`→インスタンスは`2`個だが出力は`3`
```java
public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    User.count++; // ←こいつ悪さしてる
    System.out.println(User.count);
  }
}
```
2. アクセス修飾子`private`の出番
- `USer`クラス外の`User.count++;`はエラーが出るようになるが同時に`System.out.println(User.count);`でもエラーの発生
```java
class User {
  String name;
  int score;
  private static int count = 0;

  User(String name, int score) {
    this.name = name;
    this.score = score;
    User.count++;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    User.count++;
    System.out.println(User.count);
  }
}
```
3. `getter`の設定`int getUserCount() {return User.count;}`
4. このままでは`user1.getUserCount`のように個々のインスタンスを実行する形になってしまうので`static int getUserCount() {return User.count;}`としてクラス自体に関するメソッドとする
```java
class User {
  String name;
  int score;
  private static int count = 0;

  User(String name, int score) {
    this.name = name;
    this.score = score;
    User.count++;

  static int getUserCount() {
    return User.count;
  }
}
5. 実行時はクラス名から直接メソッドを呼び出す`System.out.println(User.getUserCount());`
```java
class User {
  String name;
  int score;
  private static int count = 0;

  User(String name, int score) {
    this.name = name;
    this.score = score;
    User.count++;
  }
}

public class MyApp {
  public static void main(String[] args) {
    User user1 = new User("Taro", 70);
    User user2 = new User("Jiro", 80);

    System.out.println(User.getUserCount());
  }
}
```
### インスタンスメソッドとクラスメソッド
- `static`を付けないメソッドは個々のインスタンスに関する処理を実行する`インスタンスメソッド`
- `static`を付けたメソッドはクラス自体に関する処理を実行するので`クラスメソッド`
## 新クラスの作成
1. 点数に科目の内容も含めたいのでデータ型`Score`の作成、プログラムの拡張
2. `User user1 = new User("Taro", 70);`に整数値ではなく`Score`クラスのインスタンスを渡す`User user1 = new User("Taro", new Score("Math", 70));`ことで`Score`クラスは科目と点数を保持する
3. `User`クラスのコンストラクタに渡す値のデータ型は`User(String name, int score)`から`User(String name, Score score)`
4. また`User`クラスのフィールドのデータ型も変更`int score;`→`Score score;`
5. `Score`クラスの作成`class Score`、フィールドの決定`String subject;` `int score;`
6. `Score`クラスのコンストラクタの作成
7. `Score` `User`クラスのアクセス制限の為`private`の追加
```java
class Score {
  private String subject;
  private int score;

  Score(String subject, int score) {
    this.subject = subject;
    this.score = score;
  }
}

class User {
  private String name;
  private Score score;

  User(String name, Score score) {
    this.name = name;
    this.score = score;
  }
}

public class MyApp {
  public static void main(String[] args) {
    // User user1 = new User("Taro", 70);
    // User user2 = new User("Jiro", 80);
    User user1 = new User("Taro", new Score("Math", 70));
    User user2 = new User("Jiro", new Score("English", 80));
  }
}
```
